% Add paths
addpath('./simulation_scripts');
addpath('./tools');
addpath('./icat');
addpath('./robust_robot');
addpath('./tasks/');
clc; clear; close all;

% Simulation parameters
dt = 0.005;
endTime = 120;
% Initialize robot model and simulator
robotModel = UvmsModel();          
sim = UvmsSim(dt, robotModel, endTime);
% Initialize Unity interface
unity = UnityInterface("127.0.0.1");

%% Define desired positions and orientations (world frame)
w_arm_goal_position = [12.2025, 37.3748, -39.8860]';
w_arm_goal_orientation = [0, pi, pi/2];
w_vehicle_goal_position = [11.5, 37.5, -38]'; %w_vehicle_goal_position = [10.5, 37.5, -38]';
w_vehicle_goal_orientation = [0, -0.06, 0.5];

% Set goals in the robot model
robotModel.setGoal(...
    w_arm_goal_position,...
    w_arm_goal_orientation,...
    w_vehicle_goal_position,...
    w_vehicle_goal_orientation);

%% Define tasks and actions
% Altitude parameters
landing_altitude = 0.1;
safe_altitude = 2.0;
% Transitions trasholds (tuning)
dist_threshold = 1e-2;                      % to wp [m]
manip_threshold = 3e-2;
yaw_threshold = 1e-2;
alt_threshold = landing_altitude + 1e-2;    % landing [m]
tool_threshold = 1e-2;                     % manipulation [m]
% Parameters for manipulator
arm_reach = 0.6;
armBase_vehicle_dist = 1.1;
correction_step = 0.1;
% Task list
task_target_attitude = TaskTargetAttitude();        % P1 % da cambiare in modo che punti verso il target
task_to_altitude = TaskAltitudeControl(landing_altitude, "to_altitude"); % P2
task_min_safe_altitude = TaskAltitudeControl(safe_altitude, "safe_mode"); % P3
task_pose = TaskPoseControl();                             % P4
task_horizontal_attitude = TaskHorizontalAttitude();             % P5
% task_mantain_xy = TaskMantainxy();                                % P6
task_tool = TaskToolControl();                                               % P7
task_still_manip = TaskJointsPosition([0.0 0.0 0.0 -pi/2 0.0 -pi/2 0.0]'); % P8
task_manipulability_check = TaskManipulabilityCheck(arm_reach, armBase_vehicle_dist);
task_look_ahead = TaskLookAhead();

%---
safe_wp_nav_set  = {
    task_min_safe_altitude,...
    task_still_manip, ...
    task_horizontal_attitude,...
    task_look_ahead, ...
    task_pose, ...
    };

manipulability_check = {
    task_still_manip, ...
    task_target_attitude,...
    task_manipulability_check, ...
    task_min_safe_altitude, ...
    task_horizontal_attitude, ...
    task_look_ahead, ...
};

landing_set = {
    task_still_manip, ...
    task_to_altitude, ...
    task_manipulability_check, ...
    task_target_attitude,...
    task_horizontal_attitude, ...
    };

manip_set = {
    task_manipulability_check, ...
    task_target_attitude,... % LA FA PRIMA DEL LANDING
    task_to_altitude,...
    task_horizontal_attitude, ...
    task_tool};
%---
unified_set = {task_min_safe_altitude, ... % safety
    task_still_manip, ...
    task_to_altitude, ...
    task_target_attitude, ...
    task_manipulability_check, ...
    task_horizontal_attitude, ...
    task_look_ahead, ...
    task_pose, ...
    task_tool};

%% Define actions and add to ActionManager
actionManager = ActionManager();

actionManager.addAction(safe_wp_nav_set,"Safe Navigation");
actionManager.addAction(manipulability_check, "Manipulability Check")
actionManager.addAction(landing_set,"Landing");
actionManager.addAction(manip_set,"Manipulation");
actionManager.addUnifiedAction(unified_set);

currentState = "Safe Navigation";

actionManager.setCurrentAction(currentState);

%% Initialize the logger
logger = SimulationLogger(...
    ceil(endTime/dt)+1,...
    robotModel,...
    unified_set);

%% Main simulation loop

for step = 1:sim.maxSteps
    % 1. Receive altitude from Unity
    robotModel.altitude = unity.receiveAltitude(robotModel);
    
    % === FSM ===
    switch currentState

        case "Safe Navigation"
            [~, lin] = CartError(robotModel.wTgv , robotModel.wTv);
            horiz_dist_xy = norm(lin(1:2));
            if mod(sim.loopCounter, round(1 / sim.dt)) == 0
                fprintf("WP distance: %.2f \n", horiz_dist_xy);
            end
            if horiz_dist_xy < dist_threshold
                currentState = "Manipulability Check";
                actionManager.setCurrentAction(currentState);
                fprintf('t = %.2f s: Waypoint reached. Start Manipulability Check \n', sim.time);
            end
        case "Manipulability Check"
            % Manipulator base to target distance
            w_Tool_goal_XY = robotModel.goalPosition(1:2); % nodule
            w_Vehicle_XY = robotModel.wTv(1:2,4);
            dist_to_nodule = norm(w_Vehicle_XY - w_Tool_goal_XY);
            manip_err = dist_to_nodule - (arm_reach + armBase_vehicle_dist);

            % Yaw to target
            wPv = robotModel.wTv(1:3,4);
            wPg = robotModel.wTg(1:3,4);
            dx = wPg(1) - wPv(1);
            dy = wPg(2) - wPv(2);
            yaw_target = atan2(dy, dx);
            R_target = [cos(yaw_target) -sin(yaw_target) 0; % Roll = Pitch = 0, Yaw = yaw_target
                        sin(yaw_target) cos(yaw_target) 0;
                        0 0 1];
            wT_target = eye(4);
            wT_target(1:3, 1:3) = R_target;
            wT_target(1:3, 4) = wPv;
            
            [ang, ~] = CartError(wT_target, robotModel.wTv);
            ang_err = norm(ang);

            if mod(sim.loopCounter, round(1 / sim.dt)) == 0
                fprintf("Distance to reachability: %.2f \n", manip_err);
                fprintf("Angular error to target: %.2f \n", ang_err);
            end
            if (manip_err < manip_threshold)  && (abs(yaw_target) < yaw_threshold)
                currentState = "Landing";
                actionManager.setCurrentAction(currentState);
                fprintf('t = %.2f s: Target in manipulation range. Start Landing \n', sim.time);
            end
        case "Landing" % Check altitude and alignment
            if robotModel.altitude <= alt_threshold
                currentState = "Manipulation";
                actionManager.setCurrentAction(currentState);
                fprintf('t = %.2f s: Landing complete. Start Manipulation \n', sim.time);
            end
            
        case "Manipulation"
            % veichle is still - only manipulator movement. 
            [~, lin] = CartError(robotModel.vTg , robotModel.vTt);
            tool_dist = norm(lin);
            if mod(sim.loopCounter, round(1 / sim.dt)) == 0
                fprintf("Target distance: %.3f \n", tool_dist);
                if tool_dist < tool_threshold
                    fprintf("Target reached - Mission complete \n")
                end
            end
            
    end % === FSM ===
    


    % 2. Compute control commands for current action
    [v_nu, q_dot] = actionManager.computeICAT(robotModel);

    % 3. Step the simulator (integrate velocities)
    sim.step(v_nu, q_dot);

    % 4. Send updated state to Unity
    unity.send(robotModel);

    % 5. Logging
    logger.update(sim.time, sim.loopCounter);

    % 6. Optional debug prints
    if mod(sim.loopCounter, round(1 / sim.dt)) == 0
        fprintf('t = %.2f s\n', sim.time);
        fprintf('alt = %.2f m\n', robotModel.altitude);
        fprintf('pose = [x: %.2f y: %.2f z: %.2f] m\n', robotModel.wTv(1, 4), robotModel.wTv(2, 4), robotModel.wTv(3, 4))
    end

    % 7. Optional real-time slowdown
    SlowdownToRealtime(dt);
end

% Display plots
logger.plotAll();

% t = 0:dt:endTime;
% figure;
% plot(theta, t);

% Clean up Unity interface
delete(unity);