classdef ActionManager < handle
    properties
        actions = {}      % cell array of actions (each action = stack of tasks)
        currentAction = 1 % index of currently active action
    end

    methods

        function obj = ActionManager()
        end

        function addAction(obj, taskStack)
            % Append actions in a structure
            obj.actions{end+1} = taskStack;
        end

        function cleanAction(obj, toRemove)
            % Append actions in a structure
             obj.actions{toRemove} = [];
        end

        function [ydotbar] = computeICAT(obj,bm_system, arm1, arm2)
            tasks = obj.actions{obj.currentAction};
            %% 1. Update references, Jacobians, activations
            for i = 1:length(tasks)
                tasks{i}.updateReference(bm_system);
                tasks{i}.updateJacobian(bm_system);
                tasks{i}.updateActivation(bm_system);
            end
            
            %% 2. Perform ICAT (task-priority inverse kinematics) for the current Action
            ydotbar = zeros(14,1);
            Qp = eye(14);
            for i = 1:length(tasks)
                 %% TRANSITION FROM PREVIOUS ACTION SET TO NEXT ACTION SET
                [Qp, ydotbar] = iCAT_task(tasks{i}.A, tasks{i}.J, ...
                                           Qp, ydotbar, tasks{i}.xdotbar, ...
                                           1e-4, 0.01, 10);
            end
            %% 3. Last task: residual damping
            [~, ydotbar] = iCAT_task(eye(14), eye(14), Qp, ydotbar, zeros(14,1), 1e-4, 0.01, 10);

            if arm1.grasped &&  arm2.grasped

                X_o1 = arm1.wJo*q_dot(1:7);
                X_o2 = arm2.wJo*q_dot(8:14);
            
                H_1 = arm1.wJo*pinv(arm1.wJo);
                H_2 = arm2.wJo*pinv(arm2.wJo);
                H_12 = [H_1 zeros(6,6);zeros(6,6) H_2];
            
                [v_ang, v_lin] = CartError(arm1.wTgo , arm1.wTo);
                xdotbar = 1.0 * [v_ang; v_lin];
                xdotbar(1:3) = Saturate(xdotbar(1:3), 0.3);
                xdotbar(4:6) = Saturate(xdotbar(4:6), 0.3);
            
                mu_1 = mu_0 + norm(xdotbar-X_o1);
                mu_2 = mu_0 + norm(xdotbar-X_o2);
            
                xdot_t = (mu_1*X_t1+mu_2*X_t2)/(mu_1+mu_2);
            
                Xdot_t = [xdot_t;xdot_t];
            
                C = [H_1 -H_2];
            
                Xt_1_2 = H_12*(eye(6) - pinv(C)*C)*Xdot_t;
                
                lb_ID = find([tasks.taskID] == "LB", 1);
                rb_ID = find([tasks.taskID] == "RB", 1);
    
                tasks{lb_ID}.xdotbar = Xt_1_2(1:6,:);
                tasks{rb_ID}.xdotbar = Xt_1_2(7:12,:);
                
                tasks = [tasks{rb_ID}, tasks{1:rb_ID-1}, tasks{rb_ID+1:end}];
                tasks = [tasks{lb_ID}, tasks{1:lb_ID-1}, tasks{lb_ID+1:end}];
                
    
                for i = 1:length(tasks)
                     %% TRANSITION FROM PREVIOUS ACTION SET TO NEXT ACTION SET
                    [Qp, ydotbar] = iCAT_task(tasks{i}.A, tasks{i}.J, ...
                                               Qp, ydotbar, tasks{i}.xdotbar, ...
                                               1e-4, 0.01, 10);
                end
                %% 3. Last task: residual damping
                [~, ydotbar] = iCAT_task(eye(14), eye(14), Qp, ydotbar, zeros(14,1), 1e-4, 0.01, 10);
            end
        end


        function setCurrentAction(obj, actionIndex)
            % Switch to a different action
            if actionIndex >= 1 && actionIndex <= length(obj.actions)
                obj.currentAction = actionIndex;
            else
                error('Action index out of range');
            end
        end
    end
end